<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matchflix</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'SF Pro Display', 'Segoe UI', sans-serif;
      background: #000000;
      color: #f5f5f7;
      min-height: 100vh;
    }

    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      animation: fadeIn 0.6s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
      animation: slideDown 0.8s ease-out;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1 {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'SF Pro Display', sans-serif;
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #ffffff 0%, #a0a0a0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }

    .tagline {
      font-size: 1.1rem;
      color: #86868b;
      font-weight: 400;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 2rem;
      animation: slideUp 0.8s ease-out 0.2s both;
    }

    .search-container {
      width: 100%;
      max-width: 600px;
      margin: 0 auto 1rem;
      animation: slideUp 0.8s ease-out 0.15s both;
    }

    .search-bar {
      width: 100%;
      padding: 0.875rem 1.25rem;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      color: #f5f5f7;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 1rem;
      backdrop-filter: blur(20px);
      transition: all 0.3s ease;
    }

    .search-bar::placeholder {
      color: #86868b;
    }

    .search-bar:focus {
      outline: none;
      border-color: #0071e3;
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.2);
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .user-switch, .view-switch, .tab-switch, .category-switch, .streaming-switch {
      display: flex;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.08);
      padding: 0.5rem;
      border-radius: 12px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .control-btn, .tab-btn {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      color: #f5f5f7;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .control-btn:hover, .tab-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
    }

    .control-btn.active, .tab-btn.active {
      background: #0071e3;
      color: white;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 113, 227, 0.3);
    }

    .content-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      animation: gridFadeIn 0.8s ease-out 0.4s both;
    }

    @keyframes gridFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .content-card {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      animation: cardAppear 0.6s ease-out both;
    }

    @keyframes cardAppear {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .content-card:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .content-card.matched {
      border: 1px solid #0071e3;
      background: rgba(0, 113, 227, 0.1);
      box-shadow: 0 8px 25px rgba(0, 113, 227, 0.2);
    }

    .poster-container {
      position: relative;
      aspect-ratio: 2/3;
      background: rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .poster {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.4s ease;
    }

    .content-card:hover .poster {
      transform: scale(1.05);
    }

    .poster-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.3);
      font-size: 3rem;
    }

    .match-badge {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #0071e3;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
      font-size: 0.85rem;
      box-shadow: 0 4px 15px rgba(0, 113, 227, 0.4);
      animation: badgePulse 2s ease-in-out infinite;
    }

    @keyframes badgePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .content-info {
      padding: 1.25rem;
    }

    .content-title {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #f5f5f7;
      line-height: 1.3;
      letter-spacing: -0.01em;
    }

    .content-meta {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #86868b;
    }

    .content-description {
      font-size: 0.9rem;
      line-height: 1.5;
      color: #86868b;
      margin-bottom: 1rem;
    }

    .streaming-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .streaming-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.35rem 0.75rem;
      background: rgba(0, 113, 227, 0.15);
      border: 1px solid rgba(0, 113, 227, 0.3);
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
      color: #0071e3;
    }

    .trailer-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 1rem;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #f5f5f7;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      text-decoration: none;
      transition: all 0.3s ease;
      margin-bottom: 1rem;
    }

    .trailer-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-1px);
    }

    .rating {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      color: #f5a623;
    }

    .rating-buttons {
      display: flex;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .rating-btn {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: #f5f5f7;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .rating-btn:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.12);
    }

    .rating-btn.interested.active {
      background: #0071e3;
      border-color: #0071e3;
      color: white;
      box-shadow: 0 4px 15px rgba(0, 113, 227, 0.3);
    }

    .rating-btn.not-interested.active {
      background: rgba(134, 134, 139, 0.3);
      border-color: rgba(134, 134, 139, 0.5);
      color: #86868b;
    }

    .rating-btn.remove-btn {
      background: rgba(255, 59, 48, 0.1);
      border-color: rgba(255, 59, 48, 0.3);
      color: #ff3b30;
    }

    .rating-btn.remove-btn:hover {
      background: rgba(255, 59, 48, 0.2);
      border-color: rgba(255, 59, 48, 0.5);
    }

    .interest-indicators {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .indicator {
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      font-size: 0.85rem;
      text-align: center;
    }

    .loading {
      text-align: center;
      padding: 4rem 2rem;
      font-size: 1.2rem;
      color: #86868b;
    }

    .empty-state {
      text-align: center;
      padding: 4rem 2rem;
      color: #86868b;
    }

    .empty-state h3 {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      font-size: 2rem;
      margin-bottom: 1rem;
      color: #f5f5f7;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .api-notice {
      background: rgba(0, 113, 227, 0.1);
      border: 1px solid rgba(0, 113, 227, 0.3);
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      text-align: center;
      animation: slideUp 0.8s ease-out 0.1s both;
    }

    .api-notice h3 {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      color: #0071e3;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .api-notice p {
      color: #86868b;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .api-notice a {
      color: #0071e3;
      text-decoration: none;
      font-weight: 600;
    }

    .api-notice a:hover {
      text-decoration: underline;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }

      .content-grid {
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 1.5rem;
      }

      .controls {
        flex-direction: column;
      }

      .user-switch, .view-switch, .tab-switch {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Matchflix</h1>
      <p class="tagline">Find something you'll both love to watch</p>
    </header>

    <div id="apiNotice" class="api-notice">
      <h3>Setup Required</h3>
      <p>
        To use this app, you need a free TMDb API key. Get one at 
        <a href="https://www.themoviedb.org/settings/api" target="_blank" rel="noopener noreferrer">
          themoviedb.org/settings/api
        </a>
        and replace 'YOUR_API_KEY_HERE' in the code (line 350).
      </p>
    </div>

    <div class="search-container" id="searchContainer">
      <input 
        type="text" 
        class="search-bar" 
        id="searchBar"
        placeholder="üîç Search for movies and TV shows..."
      />
    </div>

    <div class="controls">
      <div class="user-switch">
        <button class="control-btn active" data-user="person1">Eilean</button>
        <button class="control-btn" data-user="person2">Fivos</button>
      </div>

      <div class="view-switch">
        <button class="control-btn active" data-view="rate">Rate Content</button>
        <button class="control-btn" data-view="matches">
          <span>‚ú®</span> Matches
        </button>
        <button class="control-btn" data-view="mylist">My List</button>
      </div>

      <div class="streaming-switch" id="streamingSwitch">
        <button class="tab-btn active" data-streaming="all">All Services</button>
        <button class="tab-btn" data-streaming="hulu">Hulu</button>
        <button class="tab-btn" data-streaming="disney">Disney+</button>
        <button class="tab-btn" data-streaming="prime">Prime Video</button>
        <button class="tab-btn" data-streaming="apple">Apple TV+</button>
        <button class="tab-btn" data-streaming="netflix">Netflix</button>
        <button class="tab-btn" data-streaming="paramount">Paramount+</button>
        <button class="tab-btn" data-streaming="hbo">Max</button>
      </div>

      <div class="category-switch" id="categorySwitch">
        <button class="tab-btn active" data-category="trending">Trending</button>
        <button class="tab-btn" data-category="popular">Popular</button>
        <button class="tab-btn" data-category="top_rated">Top Rated</button>
      </div>

      <div class="tab-switch" id="tabSwitch">
        <button class="tab-btn active" data-tab="movies">
          <span>üé¨</span> Movies
        </button>
        <button class="tab-btn" data-tab="tv">
          <span>üì∫</span> TV Shows
        </button>
      </div>
    </div>

    <div id="contentContainer"></div>
  </div>

  <script>
    // TMDb API configuration
    const TMDB_API_KEY = 'a781f5168ff3df908b3f1d4214ad0e6e';
    const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
    const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

    // App state
    let state = {
      movies: [],
      tvShows: [],
      activeTab: 'movies',
      currentUser: 'person1',
      viewMode: 'rate',
      category: 'trending', // trending, popular, top_rated
      streamingProvider: 'all', // all, hulu, disney, prime, apple, netflix, paramount, hbo
      searchQuery: '', // search query
      ratings: JSON.parse(localStorage.getItem('movieMatcherRatings') || '{}'),
      ratedItems: JSON.parse(localStorage.getItem('movieMatcherRatedItems') || '{}'), // Store full item data for rated content
      loading: true,
      trailers: {}, // Store trailer data
      providers: {} // Store streaming provider data
    };

    // Global cache of all items we've seen (for My List functionality)
    let itemsCache = {};

    // Initialize app
    async function init() {
      await fetchTrendingContent();
      setupEventListeners();
      render();
      
      // Hide API notice if key is set
      if (TMDB_API_KEY !== 'YOUR_API_KEY_HERE') {
        document.getElementById('apiNotice').style.display = 'none';
      }
    }

    // Helper function to truncate to full sentences
    function truncateToSentences(text, maxSentences = 2) {
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
      return sentences.slice(0, maxSentences).join(' ').trim();
    }

    // Fetch trailer for a specific item
    async function fetchTrailer(itemId, itemType) {
      const key = `${itemType}-${itemId}`;
      if (state.trailers[key]) return state.trailers[key];

      try {
        const response = await fetch(
          `${TMDB_BASE_URL}/${itemType}/${itemId}/videos?api_key=${TMDB_API_KEY}`
        );
        const data = await response.json();
        
        // Find official trailer or teaser
        const trailer = data.results?.find(
          video => video.type === 'Trailer' && video.site === 'YouTube'
        ) || data.results?.find(
          video => video.type === 'Teaser' && video.site === 'YouTube'
        );

        if (trailer) {
          state.trailers[key] = `https://www.youtube.com/watch?v=${trailer.key}`;
          return state.trailers[key];
        }
      } catch (error) {
        console.error('Error fetching trailer:', error);
      }
      
      return null;
    }

    // Fetch streaming providers for a specific item
    async function fetchProviders(itemId, itemType) {
      const key = `${itemType}-${itemId}`;
      if (state.providers[key]) return state.providers[key];

      try {
        const response = await fetch(
          `${TMDB_BASE_URL}/${itemType}/${itemId}/watch/providers?api_key=${TMDB_API_KEY}`
        );
        const data = await response.json();
        
        // Get US providers
        const usProviders = data.results?.US?.flatrate || [];
        
        // Map provider IDs to names we care about
        const providerMap = {
          15: 'Hulu',
          337: 'Disney+',
          9: 'Prime Video',
          350: 'Apple TV+',
          8: 'Netflix',
          531: 'Paramount+',
          1899: 'Max'
        };
        
        const availableOn = usProviders
          .filter(p => providerMap[p.provider_id])
          .map(p => providerMap[p.provider_id]);
        
        state.providers[key] = availableOn;
        return availableOn;
      } catch (error) {
        console.error('Error fetching providers:', error);
      }
      
      return [];
    }

    // Fetch trending content
    async function fetchTrendingContent() {
      state.loading = true;
      render();
      
      try {
        // Watch provider IDs for US region:
        // Hulu = 15, Disney+ = 337, Prime Video = 9, Apple TV+ = 350
        // Netflix = 8, Paramount+ = 531, Max (formerly HBO Max) = 1899
        const providerMap = {
          'all': '15|337|9|350|8|531|1899',
          'hulu': '15',
          'disney': '337',
          'prime': '9',
          'apple': '350',
          'netflix': '8',
          'paramount': '531',
          'hbo': '1899'
        };
        
        const providers = providerMap[state.streamingProvider];
        const region = 'US'; // United States
        
        let moviesRes, tvRes;
        
        // If there's a search query, use the search endpoint
        if (state.searchQuery.trim()) {
          moviesRes = await fetch(
            `${TMDB_BASE_URL}/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(state.searchQuery)}&page=1`
          );
          tvRes = await fetch(
            `${TMDB_BASE_URL}/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(state.searchQuery)}&page=1`
          );
        } else if (state.category === 'trending') {
          // Trending - sorted by popularity
          moviesRes = await fetch(
            `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=popularity.desc&page=1`
          );
          tvRes = await fetch(
            `${TMDB_BASE_URL}/discover/tv?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=popularity.desc&page=1`
          );
        } else if (state.category === 'popular') {
          // Popular with streaming filters
          moviesRes = await fetch(
            `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=popularity.desc&page=1`
          );
          tvRes = await fetch(
            `${TMDB_BASE_URL}/discover/tv?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=popularity.desc&page=1`
          );
        } else if (state.category === 'top_rated') {
          // Top rated with streaming filters
          moviesRes = await fetch(
            `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=vote_average.desc&vote_count.gte=1000&page=1`
          );
          tvRes = await fetch(
            `${TMDB_BASE_URL}/discover/tv?api_key=${TMDB_API_KEY}&watch_region=${region}&with_watch_providers=${providers}&sort_by=vote_average.desc&vote_count.gte=500&page=1`
          );
        }

        const moviesData = await moviesRes.json();
        const tvData = await tvRes.json();

        state.movies = moviesData.results || [];
        state.tvShows = tvData.results || [];
      } catch (error) {
        console.error('Error fetching content:', error);
      }
      
      state.loading = false;
      render();
    }

    // Event listeners
    function setupEventListeners() {
      // Search bar
      const searchBar = document.getElementById('searchBar');
      let searchTimeout;
      searchBar.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(async () => {
          state.searchQuery = e.target.value;
          await fetchTrendingContent();
        }, 500); // Debounce search by 500ms
      });

      // User switch
      document.querySelectorAll('[data-user]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('[data-user]').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          state.currentUser = e.target.dataset.user;
          render();
        });
      });

      // View switch
      document.querySelectorAll('[data-view]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          state.viewMode = e.target.dataset.view;
          
          // Show/hide tab switch, category switch, and streaming switch only in rate mode
          // Search bar is always visible
          const isRateMode = state.viewMode === 'rate';
          document.getElementById('tabSwitch').classList.toggle('hidden', !isRateMode);
          document.getElementById('categorySwitch').classList.toggle('hidden', !isRateMode);
          document.getElementById('streamingSwitch').classList.toggle('hidden', !isRateMode);
          render();
        });
      });

      // Streaming provider switch
      document.querySelectorAll('[data-streaming]').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          document.querySelectorAll('[data-streaming]').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          state.streamingProvider = e.target.dataset.streaming;
          await fetchTrendingContent();
        });
      });

      // Category switch
      document.querySelectorAll('[data-category]').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          document.querySelectorAll('[data-category]').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          state.category = e.target.dataset.category;
          await fetchTrendingContent();
        });
      });

      // Tab switch
      document.querySelectorAll('[data-tab]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('[data-tab]').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          state.activeTab = e.target.dataset.tab;
          render();
        });
      });
    }

    // Handle rating
    function handleRating(itemId, itemType, interested) {
      const key = `${itemType}-${itemId}`;
      if (!state.ratings[key]) {
        state.ratings[key] = {};
      }
      
      // Toggle off if clicking the same rating again
      if (state.ratings[key][state.currentUser] === interested) {
        state.ratings[key][state.currentUser] = null; // Unselect
      } else {
        state.ratings[key][state.currentUser] = interested;
      }
      
      localStorage.setItem('movieMatcherRatings', JSON.stringify(state.ratings));
      
      // Always store the full item data when rating (regardless of interested or not)
      // This ensures items from search are captured
      if (itemsCache[key]) {
        state.ratedItems[key] = itemsCache[key];
        localStorage.setItem('movieMatcherRatedItems', JSON.stringify(state.ratedItems));
      }
      
      render();
    }

    // Get item rating
    function getItemRating(itemId, itemType) {
      return state.ratings[`${itemType}-${itemId}`] || {};
    }

    // Get current items
    function getCurrentItems() {
      return state.activeTab === 'movies' ? state.movies : state.tvShows;
    }

    // Get matches
    function getMatches() {
      const allItems = [...state.movies, ...state.tvShows];
      return allItems.filter(item => {
        const itemType = item.title ? 'movie' : 'tv';
        const rating = getItemRating(item.id, itemType);
        return rating.person1 === true && rating.person2 === true;
      });
    }

    // Get user's list
    function getMyList() {
      // Get all items that the current user has rated as interested
      const myRatedItems = [];
      
      console.log('Getting My List for:', state.currentUser);
      console.log('All ratings:', state.ratings);
      console.log('Rated items in storage:', state.ratedItems);
      
      for (const key in state.ratings) {
        const rating = state.ratings[key];
        if (rating[state.currentUser] === true) {
          // Check if we have the item data stored
          if (state.ratedItems[key]) {
            console.log('Adding item from storage:', key, state.ratedItems[key].title || state.ratedItems[key].name);
            myRatedItems.push(state.ratedItems[key]);
          } else {
            console.log('Missing item data for:', key);
          }
        }
      }
      
      // Also include items from current view that are rated
      const currentItems = [...state.movies, ...state.tvShows];
      currentItems.forEach(item => {
        const itemType = item.title ? 'movie' : 'tv';
        const key = `${itemType}-${item.id}`;
        const rating = getItemRating(item.id, itemType);
        
        if (rating[state.currentUser] === true) {
          // Add to ratedItems if not already there
          if (!state.ratedItems[key]) {
            state.ratedItems[key] = item;
            localStorage.setItem('movieMatcherRatedItems', JSON.stringify(state.ratedItems));
          }
          
          // Add to list if not already included
          const alreadyIncluded = myRatedItems.some(i => {
            const iType = i.title ? 'movie' : 'tv';
            return iType === itemType && i.id === item.id;
          });
          
          if (!alreadyIncluded) {
            myRatedItems.push(item);
          }
        }
      });
      
      console.log('Final My List items:', myRatedItems.length);
      return myRatedItems;
    }

    // Create content card HTML
    async function createContentCard(item) {
      const itemType = item.title ? 'movie' : 'tv';
      const key = `${itemType}-${item.id}`;
      
      // Cache this item for later use in My List
      itemsCache[key] = item;
      
      const rating = getItemRating(item.id, itemType);
      const title = item.title || item.name;
      const date = item.release_date || item.first_air_date;
      const year = date ? new Date(date).getFullYear() : '';
      
      const isBothInterested = rating.person1 === true && rating.person2 === true;
      const person1Interested = rating.person1 === true;
      const person2Interested = rating.person2 === true;

      // Fetch trailer and providers
      const trailerUrl = await fetchTrailer(item.id, itemType);
      const providers = await fetchProviders(item.id, itemType);

      return `
        <div class="content-card ${isBothInterested ? 'matched' : ''}">
          <div class="poster-container">
            ${item.poster_path 
              ? `<img src="${TMDB_IMAGE_BASE}${item.poster_path}" alt="${title}" class="poster">`
              : `<div class="poster-placeholder">${itemType === 'movie' ? 'üé¨' : 'üì∫'}</div>`
            }
            ${isBothInterested ? '<div class="match-badge"><span>‚ú®</span><span>Match!</span></div>' : ''}
          </div>
          
          <div class="content-info">
            <h3 class="content-title">${title}</h3>
            <div class="content-meta">
              <span class="year">${year}</span>
              ${item.vote_average > 0 
                ? `<span class="rating">‚≠ê ${item.vote_average.toFixed(1)}</span>`
                : ''
              }
            </div>
            ${item.overview ? `<p class="content-description">${truncateToSentences(item.overview, 2)}</p>` : ''}
            ${providers.length > 0 ? `
              <div class="streaming-badges">
                ${providers.map(p => `<span class="streaming-badge">${p}</span>`).join('')}
              </div>
            ` : ''}
            ${trailerUrl ? `<a href="${trailerUrl}" target="_blank" class="trailer-btn">‚ñ∂Ô∏è Watch Trailer</a>` : ''}
            
            ${state.viewMode === 'rate' ? `
              <div class="rating-buttons">
                <button 
                  onclick="handleRating(${item.id}, '${itemType}', false)"
                  class="rating-btn not-interested ${rating[state.currentUser] === false ? 'active' : ''}"
                >
                  ‚úï Pass
                </button>
                <button 
                  onclick="handleRating(${item.id}, '${itemType}', true)"
                  class="rating-btn interested ${rating[state.currentUser] === true ? 'active' : ''}"
                >
                  ‚ù§Ô∏è Interested
                </button>
              </div>
            ` : state.viewMode === 'mylist' ? `
              <div class="rating-buttons">
                <button 
                  onclick="handleRating(${item.id}, '${itemType}', true)"
                  class="rating-btn remove-btn"
                >
                  ‚úï Remove from My List
                </button>
              </div>
            ` : `
              <div class="interest-indicators">
                ${person1Interested ? '<div class="indicator person1">Eilean ‚ù§Ô∏è</div>' : ''}
                ${person2Interested ? '<div class="indicator person2">Fivos ‚ù§Ô∏è</div>' : ''}
              </div>
            `}
          </div>
        </div>
      `;
    }

    // Render app
    async function render() {
      const container = document.getElementById('contentContainer');
      
      if (state.loading) {
        container.innerHTML = '<div class="loading">Loading trending content...</div>';
        return;
      }

      let items = [];
      let emptyMessage = '';

      if (state.viewMode === 'rate') {
        items = getCurrentItems();
      } else if (state.viewMode === 'matches') {
        items = getMatches();
        emptyMessage = '<div class="empty-state"><h3>No matches yet</h3><p>Start rating content to find your perfect matches!</p></div>';
      } else if (state.viewMode === 'mylist') {
        items = getMyList();
        emptyMessage = '<div class="empty-state"><h3>Your list is empty</h3><p>Mark some movies or shows as interested to build your list!</p></div>';
      }

      if (items.length === 0 && emptyMessage) {
        container.innerHTML = emptyMessage;
      } else {
        // Create all cards asynchronously
        const cardPromises = items.map(item => createContentCard(item));
        const cards = await Promise.all(cardPromises);
        
        container.innerHTML = `
          <div class="content-grid">
            ${cards.join('')}
          </div>
        `;
      }
    }

    // Start the app
    init();
  </script>
</body>
</html>
